import os

class Config:
    """Base configuration class"""
    SECRET_KEY = os.environ.get('SESSION_SECRET') or 'dev-secret-key-change-in-production'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_ENGINE_OPTIONS = {
        "pool_recycle": 300,
        "pool_pre_ping": True,
    }

class DevelopmentConfig(Config):
    """Development configuration for local MySQL"""
    DEBUG = True
    
    @staticmethod
    def get_database_uri():
        # Check if DATABASE_URL is set (Replit PostgreSQL)
        database_url = os.environ.get("DATABASE_URL")
        if database_url:
            return database_url
        
        # Check if pymysql is available and MySQL is configured
        try:
            import pymysql
            # Check if MySQL environment variables are properly set
            mysql_user = os.environ.get("root")
            mysql_password = os.environ.get("root@123")
            mysql_host = os.environ.get("localhost")
            mysql_database = os.environ.get("wms_dev.db")
            
            # Only try MySQL if all required variables are set
            if mysql_user and mysql_password and mysql_host and mysql_database:
                mysql_port = os.environ.get("MYSQL_PORT", "3306")
                return f"mysql+pymysql://{mysql_user}:{mysql_password}@{mysql_host}:{mysql_port}/{mysql_database}"
            else:
                # Fallback to SQLite if MySQL not properly configured
                db_path = os.path.join(os.getcwd(), 'wms_dev.db')
                return f"sqlite:///{db_path}"
        except ImportError:
            # Fallback to SQLite for development if pymysql is not available
            db_path = os.path.join(os.getcwd(), 'wms_dev.db')
            return f"sqlite:///{db_path}"

class ProductionConfig(Config):
    """Production configuration"""
    DEBUG = False
    
    @staticmethod
    def get_database_uri():
        database_url = os.environ.get("DATABASE_URL")
        if not database_url:
            raise ValueError("DATABASE_URL environment variable must be set in production")
        return database_url

class ReplitConfig(Config):
    """Replit specific configuration"""
    DEBUG = True
    
    @staticmethod
    def get_database_uri():
        database_url = os.environ.get("DATABASE_URL")
        if not database_url:
            raise ValueError("DATABASE_URL not found in Replit environment")
        return database_url

# Configuration dictionary
config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'replit': ReplitConfig,
    'default': DevelopmentConfig
}